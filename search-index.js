var searchIndex = {};
searchIndex["embedded_hal"] = {"doc":"A Hardware Abstraction Layer (HAL) for embedded systems","items":[[4,"Direction","embedded_hal","Count direction",null,null],[13,"Downcounting","","3, 2, 1",0,null],[13,"Upcounting","","1, 2, 3",0,null],[0,"blocking","","Blocking API",null,null],[0,"delay","embedded_hal::blocking","Delays",null,null],[8,"DelayMs","embedded_hal::blocking::delay","Millisecond delay",null,null],[10,"delay_ms","","Pauses execution for `ms` milliseconds",1,{"i":[{"n":"self"},{"n":"uxx"}]}],[8,"DelayUs","","Microsecond delay",null,null],[10,"delay_us","","Pauses execution for `us` microseconds",2,{"i":[{"n":"self"},{"n":"uxx"}]}],[0,"i2c","embedded_hal::blocking","Blocking I2C API",null,null],[8,"Read","embedded_hal::blocking::i2c","Blocking read",null,null],[16,"Error","","Error type",3,null],[10,"read","","Reads enough bytes from slave with `address` to fill `buffer`",3,null],[8,"Write","","Blocking write",null,null],[16,"Error","","Error type",4,null],[10,"write","","Sends bytes to slave with address `addr`",4,null],[8,"WriteRead","","Blocking write + read",null,null],[16,"Error","","Error type",5,null],[10,"write_read","","Sends bytes to slave with address `addr` and then reads enough bytes to fill `buffer` in a single transaction",5,null],[0,"serial","embedded_hal::blocking","Blocking serial API",null,null],[0,"write","embedded_hal::blocking::serial","Blocking serial write",null,null],[8,"Default","embedded_hal::blocking::serial::write","Marker trait to opt into default blocking write implementation",null,null],[8,"Write","embedded_hal::blocking::serial","Write half of a serial interface (blocking variant)",null,null],[16,"Error","","The type of error that can occur when writing",6,null],[10,"bwrite_all","","Writes a slice, blocking until everything has been written",6,null],[10,"bflush","","Block until the serial interface has sent all buffered words",6,{"i":[{"n":"self"}],"o":{"n":"result"}}],[0,"spi","embedded_hal::blocking","Blocking SPI API",null,null],[0,"transfer","embedded_hal::blocking::spi","Blocking transfer",null,null],[8,"Default","embedded_hal::blocking::spi::transfer","Default implementation of `blocking::spi::Transfer<W>` for implementers of `spi::FullDuplex<W>`",null,null],[0,"write","embedded_hal::blocking::spi","Blocking write",null,null],[8,"Default","embedded_hal::blocking::spi::write","Default implementation of `blocking::spi::Write<W>` for implementers of `spi::FullDuplex<W>`",null,null],[8,"Transfer","embedded_hal::blocking::spi","Blocking transfer",null,null],[16,"Error","","Error type",7,null],[10,"transfer","","Sends `words` to the slave. Returns the `words` received from the slave",7,null],[8,"Write","","Blocking write",null,null],[16,"Error","","Error type",8,null],[10,"write","","Sends `words` to the slave, ignoring all the incoming words",8,null],[0,"rng","embedded_hal::blocking","Blocking hardware random number generator",null,null],[8,"Read","embedded_hal::blocking::rng","Blocking read",null,null],[16,"Error","","Error type",9,null],[10,"read","","Reads enough bytes from hardware random number generator to fill `buffer`",9,null],[0,"digital","embedded_hal","Digital I/O",null,null],[0,"toggleable","embedded_hal::digital","If you can read and write the output state, a pin is toggleable by software.",null,null],[8,"Default","embedded_hal::digital::toggleable","Software-driven `toggle()` implementation.",null,null],[8,"OutputPin","embedded_hal::digital","Single digital push-pull output pin",null,null],[10,"set_low","","Drives the pin low",10,{"i":[{"n":"self"}]}],[10,"set_high","","Drives the pin high",10,{"i":[{"n":"self"}]}],[8,"StatefulOutputPin","","Push-pull output pin that can read its output state",null,null],[10,"is_set_high","","Is the pin in drive high mode?",11,{"i":[{"n":"self"}],"o":{"n":"bool"}}],[10,"is_set_low","","Is the pin in drive low mode?",11,{"i":[{"n":"self"}],"o":{"n":"bool"}}],[8,"ToggleableOutputPin","","Output pin that can be toggled",null,null],[10,"toggle","","Toggle pin output.",12,{"i":[{"n":"self"}]}],[8,"InputPin","","Single digital input pin",null,null],[10,"is_high","","Is the input pin high?",13,{"i":[{"n":"self"}],"o":{"n":"bool"}}],[10,"is_low","","Is the input pin low?",13,{"i":[{"n":"self"}],"o":{"n":"bool"}}],[0,"prelude","embedded_hal","The prelude is a collection of all the traits in this crate",null,null],[0,"serial","","Serial interface",null,null],[8,"Read","embedded_hal::serial","Read half of a serial interface",null,null],[16,"Error","","Read error",14,null],[10,"read","","Reads a single word from the serial interface",14,{"i":[{"n":"self"}],"o":{"n":"result"}}],[8,"Write","","Write half of a serial interface",null,null],[16,"Error","","Write error",15,null],[10,"write","","Writes a single word to the serial interface",15,{"i":[{"n":"self"},{"n":"word"}],"o":{"n":"result"}}],[10,"flush","","Ensures that none of the previously written words are still buffered",15,{"i":[{"n":"self"}],"o":{"n":"result"}}],[0,"spi","embedded_hal","Serial Peripheral Interface",null,null],[3,"Mode","embedded_hal::spi","SPI mode",null,null],[12,"polarity","","Clock polarity",16,null],[12,"phase","","Clock phase",16,null],[4,"Polarity","","Clock polarity",null,null],[13,"IdleLow","","Clock signal low when idle",17,null],[13,"IdleHigh","","Clock signal high when idle",17,null],[4,"Phase","","Clock phase",null,null],[13,"CaptureOnFirstTransition","","Data in \"captured\" on the first clock transition",18,null],[13,"CaptureOnSecondTransition","","Data in \"captured\" on the second clock transition",18,null],[8,"FullDuplex","","Full duplex (master mode)",null,null],[16,"Error","","An enumeration of SPI errors",19,null],[10,"read","","Reads the word stored in the shift register",19,{"i":[{"n":"self"}],"o":{"n":"result"}}],[10,"send","","Sends a word to the slave",19,{"i":[{"n":"self"},{"n":"word"}],"o":{"n":"result"}}],[11,"clone","","",17,{"i":[{"n":"self"}],"o":{"n":"polarity"}}],[11,"eq","","",17,{"i":[{"n":"self"},{"n":"polarity"}],"o":{"n":"bool"}}],[11,"clone","","",18,{"i":[{"n":"self"}],"o":{"n":"phase"}}],[11,"eq","","",18,{"i":[{"n":"self"},{"n":"phase"}],"o":{"n":"bool"}}],[11,"clone","","",16,{"i":[{"n":"self"}],"o":{"n":"mode"}}],[11,"eq","","",16,{"i":[{"n":"self"},{"n":"mode"}],"o":{"n":"bool"}}],[11,"ne","","",16,{"i":[{"n":"self"},{"n":"mode"}],"o":{"n":"bool"}}],[0,"timer","embedded_hal","Timers",null,null],[8,"CountDown","embedded_hal::timer","A count down timer",null,null],[16,"Time","","The unit of time used by this timer",20,null],[10,"start","","Starts a new count down",20,{"i":[{"n":"self"},{"n":"t"}]}],[10,"wait","","Non-blockingly \"waits\" until the count down finishes",20,{"i":[{"n":"self"}],"o":{"g":["void"],"n":"result"}}],[8,"Periodic","","Marker trait that indicates that a timer is periodic",null,null],[8,"Capture","embedded_hal","Input capture",null,null],[16,"Error","","Enumeration of `Capture` errors",21,null],[16,"Channel","","Enumeration of channels that can be used with this `Capture` interface",21,null],[16,"Time","","A time unit that can be converted into a human time unit (e.g. seconds)",21,null],[16,"Capture","","The type of the value returned by `capture`",21,null],[10,"capture","","\"Waits\" for a transition in the capture `channel` and returns the value of counter at that instant",21,null],[10,"disable","","Disables a capture `channel`",21,null],[10,"enable","","Enables a capture `channel`",21,null],[10,"get_resolution","","Returns the current resolution",21,null],[10,"set_resolution","","Sets the resolution of the capture timer",21,{"i":[{"n":"self"},{"n":"r"}]}],[8,"Pwm","","Pulse Width Modulation",null,null],[16,"Channel","","Enumeration of channels that can be used with this `Pwm` interface",22,null],[16,"Time","","A time unit that can be converted into a human time unit (e.g. seconds)",22,null],[16,"Duty","","Type for the `duty` methods",22,null],[10,"disable","","Disables a PWM `channel`",22,null],[10,"enable","","Enables a PWM `channel`",22,null],[10,"get_period","","Returns the current PWM period",22,null],[10,"get_duty","","Returns the current duty cycle",22,null],[10,"get_max_duty","","Returns the maximum duty cycle value",22,null],[10,"set_duty","","Sets a new duty cycle",22,null],[10,"set_period","","Sets a new PWM period",22,{"i":[{"n":"self"},{"n":"p"}]}],[8,"PwmPin","","A single PWM channel / pin",null,null],[16,"Duty","","Type for the `duty` methods",23,null],[10,"disable","","Disables a PWM `channel`",23,{"i":[{"n":"self"}]}],[10,"enable","","Enables a PWM `channel`",23,{"i":[{"n":"self"}]}],[10,"get_duty","","Returns the current duty cycle",23,null],[10,"get_max_duty","","Returns the maximum duty cycle value",23,null],[10,"set_duty","","Sets a new duty cycle",23,null],[8,"Qei","","Quadrature encoder interface",null,null],[16,"Count","","The type of the value returned by `count`",24,null],[10,"count","","Returns the current pulse count of the encoder",24,null],[10,"direction","","Returns the count direction",24,{"i":[{"n":"self"}],"o":{"n":"direction"}}],[11,"clone","","",0,{"i":[{"n":"self"}],"o":{"n":"direction"}}],[11,"fmt","","",0,{"i":[{"n":"self"},{"n":"formatter"}],"o":{"n":"result"}}],[11,"eq","","",0,{"i":[{"n":"self"},{"n":"direction"}],"o":{"n":"bool"}}]],"paths":[[4,"Direction"],[8,"DelayMs"],[8,"DelayUs"],[8,"Read"],[8,"Write"],[8,"WriteRead"],[8,"Write"],[8,"Transfer"],[8,"Write"],[8,"Read"],[8,"OutputPin"],[8,"StatefulOutputPin"],[8,"ToggleableOutputPin"],[8,"InputPin"],[8,"Read"],[8,"Write"],[3,"Mode"],[4,"Polarity"],[4,"Phase"],[8,"FullDuplex"],[8,"CountDown"],[8,"Capture"],[8,"Pwm"],[8,"PwmPin"],[8,"Qei"]]};
searchIndex["max31865"] = {"doc":"A generic driver for the MAX31865 RTD to Digital converter","items":[[3,"Max31865","max31865","",null,null],[4,"FilterMode","","",null,null],[13,"Filter60Hz","","",0,null],[13,"Filter50Hz","","",0,null],[4,"SensorType","","",null,null],[13,"TwoOrFourWire","","",1,null],[13,"ThreeWire","","",1,null],[0,"examples","","Examples",null,null],[0,"_00_stm32","max31865::examples","An example of reading the temperature.",null,null],[0,"_01_stm32_ssd1306","","An example of reading the temperature and writing it to a screen.",null,null],[0,"_02_rpi","","Raspberry Pi demo",null,null],[0,"temp_conversion","max31865","Temperature conversion table and lookup function",null,null],[5,"lookup_temperature","max31865::temp_conversion","Convert the specified PT100 resistance value into a temperature.",null,{"i":[{"n":"u16"}],"o":{"n":"u32"}}],[17,"MODE","max31865","",null,null],[11,"new","","Create a new MAX31865 module.",2,{"i":[{"n":"spi"},{"n":"ncs"},{"n":"rdy"}],"o":{"g":["max31865"],"n":"result"}}],[11,"configure","","Updates the devices configuration.",2,{"i":[{"n":"self"},{"n":"bool"},{"n":"bool"},{"n":"bool"},{"n":"sensortype"},{"n":"filtermode"}],"o":{"n":"result"}}],[11,"set_calibration","","Set the calibration reference resistance. This can be used to calibrate inaccuracies of both the reference resistor  and the PT100 element.",2,{"i":[{"n":"self"},{"n":"u32"}],"o":{"n":"result"}}],[11,"read_default_conversion","","Read the raw resistance value and then perform conversion to degrees Celcius.",2,{"i":[{"n":"self"}],"o":{"g":["u32"],"n":"result"}}],[11,"read_raw","","Read the raw RTD value.",2,{"i":[{"n":"self"}],"o":{"g":["u16"],"n":"result"}}],[11,"is_ready","","Determine if a new conversion is available",2,{"i":[{"n":"self"}],"o":{"g":["bool"],"n":"result"}}]],"paths":[[4,"FilterMode"],[4,"SensorType"],[3,"Max31865"]]};
searchIndex["nb"] = {"doc":"Minimal and reusable non-blocking I/O layer","items":[[4,"Error","nb","A non-blocking error",null,null],[13,"Other","","A different kind of error",0,null],[13,"WouldBlock","","This operation requires blocking behavior to complete",0,null],[6,"Result","","A non-blocking result",null,null],[11,"clone","","",0,{"i":[{"n":"self"}],"o":{"n":"error"}}],[11,"eq","","",0,{"i":[{"n":"self"},{"n":"error"}],"o":{"n":"bool"}}],[11,"ne","","",0,{"i":[{"n":"self"},{"n":"error"}],"o":{"n":"bool"}}],[11,"partial_cmp","","",0,{"i":[{"n":"self"},{"n":"error"}],"o":{"g":["ordering"],"n":"option"}}],[11,"lt","","",0,{"i":[{"n":"self"},{"n":"error"}],"o":{"n":"bool"}}],[11,"le","","",0,{"i":[{"n":"self"},{"n":"error"}],"o":{"n":"bool"}}],[11,"gt","","",0,{"i":[{"n":"self"},{"n":"error"}],"o":{"n":"bool"}}],[11,"ge","","",0,{"i":[{"n":"self"},{"n":"error"}],"o":{"n":"bool"}}],[11,"cmp","","",0,{"i":[{"n":"self"},{"n":"error"}],"o":{"n":"ordering"}}],[11,"hash","","",0,null],[11,"fmt","","",0,{"i":[{"n":"self"},{"n":"formatter"}],"o":{"n":"result"}}],[14,"await","","Await operation (won't work until the language gains support for generators)",null,null],[14,"block","","Turns the non-blocking expression `$e` into a blocking operation.",null,null],[14,"try_nb","","Future adapter",null,null]],"paths":[[4,"Error"]]};
searchIndex["void"] = {"doc":"Void","items":[[4,"Void","void","The empty type for cases which can't occur.",null,null],[5,"unreachable","","A safe version of `intrinsincs::unreachable`.",null,null],[8,"ResultVoidExt","","Extensions to `Result<T, Void>`",null,null],[10,"void_unwrap","","Get the value out of a wrapper.",0,{"i":[{"n":"self"}],"o":{"n":"t"}}],[8,"ResultVoidErrExt","","Extensions to `Result<Void, E>`",null,null],[10,"void_unwrap_err","","Get the error out of a wrapper.",1,{"i":[{"n":"self"}],"o":{"n":"e"}}],[11,"clone","","",2,{"i":[{"n":"self"}],"o":{"n":"void"}}],[11,"fmt","","",2,{"i":[{"n":"self"},{"n":"formatter"}],"o":{"n":"result"}}],[11,"fmt","","",2,{"i":[{"n":"self"},{"n":"formatter"}],"o":{"n":"result"}}],[11,"eq","","",2,{"i":[{"n":"self"},{"n":"t"}],"o":{"n":"bool"}}],[11,"partial_cmp","","",2,{"i":[{"n":"self"},{"n":"t"}],"o":{"g":["ordering"],"n":"option"}}]],"paths":[[8,"ResultVoidExt"],[8,"ResultVoidErrExt"],[4,"Void"]]};
initSearch(searchIndex);
